cat("", file="log.txt", sep="", append=T)
getwd
getwd()
Download_GB <- function(taxon, folder=NULL, marker=c("COi", "CO1", "COXi", "COX1"), maxlength=2000, custom_query=NULL){#
#
cat(paste(Sys.time(), "- Downloading GenBank sequence data\n\n"), file="log.txt", sep="", append=T)#
#
if (is.null(custom_query)){cat(paste("Search query: REPLACE_WITH_TAXA", "[Organism] AND (", paste(c(marker), collapse=" OR "), ") AND 1:",maxlength ,"[Sequence Length]\n\n", sep=""), file="log.txt", sep="", append=T)} else {cat(paste("Search query: REPLACE_WITH_TAXA", custom_query, "\n\n", sep=""), file="log.txt", sep="", append=T)}#
#
folder_path <- ""#
if(!is.null(folder)){dir.create(folder, showWarnings=F)#
folder_path <- paste(folder, "/", sep="")#
cat(paste("#GB_data: Folder ",folder, "\n", sep=""), file="log.txt", sep="", append=T)#
} else {cat(paste("#GB_data: ", "\n", sep=""), file="log.txt", sep="", append=T)}#
cat("Taxon\tSequences\tdownl_time\n", file="log.txt", sep="", append=T)#
#
library("rentrez")#
#
for (k in 1:length(taxon)){#
time <- Sys.time() # get time#
#
# download IDs#
if (is.null(custom_query)){#
searchQ <- paste(taxon[k],"[Organism] AND (", paste(c(marker), collapse=" OR "), ") AND 1:",maxlength ,"[Sequence Length]", sep="")#
} else {searchQ <- paste(taxon, custom_query, sep="")}#
#
search_results <- entrez_search(db="nuccore", term=searchQ, retmax=9999999)#
if(length(search_results$ids)!=0){#
#
i <- 1#
while (!is.na(search_results$ids[i])){#
temp <- search_results$ids[i:(i+499)]#
temp <- temp[!is.na(temp)]#
downloaded_sequ <- entrez_fetch(db="nuccore", id=temp, rettype="fasta")#
if (downloaded_Sequ[1]!="resource temporarily unavailable (4)."){#
cat(downloaded_sequ, file=paste(folder_path, taxon[k], "_GB.fasta", sep=""), sep="", append=T)#
i <- i + 500} # only write in file if data downloaded!#
Sys.sleep(0.5)#
}#
#
meep <- read.fasta(paste(folder_path, taxon[k], "_GB.fasta", sep=""))#
if(length(meep)!=length(search_results$ids)){#
paste("WARNING: Something went wrong with the download. Numer of files in GB does not match number of downloaded files!")#
cat(paste(paste("\nWARNING: Something went wrong with the download. Numer of files in GB does not match number of downloaded files!\n\n"), file="log.txt", sep="", append=T)#
#
}#
#
}#
time <- Sys.time() - time#
print(paste("Downloaded ", length(search_results$ids)," sequences for ", taxon[k], "  in ", format(time, digits=2), sep=""))#
cat(paste(taxon[k],"\t", length(search_results$ids), "\t", format(time, digits=2), "\n", sep=""), file="log.txt", sep="", append=T)#
}#
#
cat("#GB_data_end\n\n", file="log.txt", sep="", append=T)#
}
getwd()
cat(temp, paste("../mito_no_marker/",sub(pattern, "\\1", readin[k]), ".fasta", sep=""), append=T)
?points
plot(c(1,2,3), pch=21)
plot(c(1,2,3))
paste("PrimerMiner", "/afsdf", sep="")
library("DgenPrimer")
if(range[-1]==1){""}else{"s"}
if(2==1){""}else{"s"}
if(uni_mito_coi==1){""}else{"s"}
uni_mito_coi <- 1
if(uni_mito_coi==1){""}else{"s"}
uni_mito_coi <- 2
if(uni_mito_coi==1){""}else{"s"}
print(if(uni_mito_coi==1){""}else{"s"})
Mito_GB2fasta <- function(files, marker=c("COX1", "COXi", "CO1", "COi"), add=100, rm_dup=T, pattern="\\.gb$", no_marker=T, setwd=NULL){#
#
if(!is.null(setwd)){logfile <- paste(setwd, "/log.txt", sep="")} else {logfile <- "log.txt"}#
#
cat(paste(Sys.time(), " - Converting Mito Genbank to fasta\n\n"), file=logfile, sep="", append=T)#
cat("#mito_gb2fasta\nGBfile\tnoMito\tunique\n", file=logfile, sep="", append=T)#
#
readin <- grep(pattern, files)#
if (length(readin)==0){#
	folders <- files#
	readin <- c()}else{#
folders <- files[-readin]#
readin <- files[readin]}#
#
no_coi_mito <- NULL#
#
for (i in folders){#
readin <- c(list.files(path=i, pattern=pattern, full.names=T), readin)#
}#
folder_path <- paste(folders, "/", sep="")#
for (k in 1:length(readin)){#
#
# extract fasta file!#
gb <- readLines(readin[k])#
sequence_exp <- NULL#
#
range <- grep("//", gb)#
range <- c(1, range)#
for (i in 1:length(range[-1])){#
temp <- gb[range[i]:range[i+1]]#
#
query <- paste("/(gene|CDS|product)=\"(", paste(marker, sep="", collapse="|") ,")\"", sep="")#
cds_pos <- grep("( gene   | CDS   | rRNA   )", temp)#
COX1 <- cds_pos[grep(query, temp[cds_pos+1], ignore.case=T)[1]]#
COX1 <- temp[COX1]#
if(grepl("join", COX1)){COX1 <- c(NA, NA)} else{#
COX1 <- gsub("[[:alpha:]<> ()]", "", COX1)#
COX1 <- as.numeric(c(gsub("(.*)\\.\\..*$", "\\1", COX1), gsub(".*\\.\\.(.*)$", "\\1", COX1)))}#
#
if (!is.na(COX1[1])&!is.na(COX1[2])){#
sequ <- temp[(grep("ORIGIN      ", temp)+2):length(temp)-1]#
sequ <- paste(gsub("[ 1234567890]", "", sequ), collapse="")#
#
sequ <- substr(sequ, COX1[1]-add, COX1[2]+add)#
sequ_name <- gsub(".* (.*)$", "\\1", temp[grep("ACCESSION ", temp)])#
sequence_exp <- c(sequence_exp, paste(">", sequ_name, "\n", sep=""), paste(sequ, "\n", sep=""))} else { # export mito with no marker#
no_coi_mito <- c(no_coi_mito, gsub(".* (.*)$", "\\1", temp[grep("ACCESSION ", temp)]))#
if (no_marker){dir.create("mito_no_marker", showWarnings=F)#
Fname <- sub(pattern, "\\1", readin[k])#
Fname <- sub(".*/(.*)", "\\1", Fname)#
#torder <- readLines(logfile)[grep("#mito_data: Folder .*", readLines(logfile))][1]#
#torder <- sub("#mito_data: Folder (.*)", "\\1", torder)#
Fname1 <- paste("mito_no_marker/", setwd, if(!is.null(setwd)){"_"}, Fname, ".gb", sep="")#
#
if(temp[1]=="//") ( temp <- temp[-c(1,2)])#
#
cat(temp, file=Fname1, sep="\n", append=T)}#
}#
}#
if (!is.null(sequence_exp)){#
if (rm_dup){#
dup <- !duplicated(sequence_exp[seq(2, length(sequence_exp), 2)])#
sequence_exp <- sequence_exp[rep(dup, each = 2)]}#
#
cat(sequence_exp, file=paste(sub(pattern, "\\1", readin[k]), ".fasta", sep=""), sep="") # overwrite old files#
#
# check number of unique sequences#
uni_mito_coi <- length(unique(sequence_exp[seq(2, length(sequence_exp), 2)])) } else {uni_mito_coi <- 0}#
print(paste("Converted ", length(range[-1])," mitogenome", if(range[-1]==1){""}else{"s"}," of ", readin[k], " to ", uni_mito_coi, " unique ", marker[1], " sequence", if(uni_mito_coi==1){""}else{"s"},".", sep=""))#
cat(paste(readin[k],"\t", length(range[-1]), "\t", uni_mito_coi, "\n", sep=""), file=logfile, sep="", append=T)#
}#
#
cat("#mito_gb2fasta_end\n\n", file=logfile, sep="", append=T)#
#
if (!is.null(no_coi_mito)){#
cat(paste("Mitogenomes in which no marker sequences were detected:", paste(no_coi_mito, collapse=", "), "\n\n"), file=logfile, sep="", append=T)}#
print(paste("\nMitogenomes in which no marker sequences were detected:", paste(no_coi_mito, collapse=", "), "\n"), file=logfile, sep="", append=T)}#
}
Mito_GB2fasta <- function(files, marker=c("COX1", "COXi", "CO1", "COi"), add=100, rm_dup=T, pattern="\\.gb$", no_marker=T, setwd=NULL){#
#
if(!is.null(setwd)){logfile <- paste(setwd, "/log.txt", sep="")} else {logfile <- "log.txt"}#
#
cat(paste(Sys.time(), " - Converting Mito Genbank to fasta\n\n"), file=logfile, sep="", append=T)#
cat("#mito_gb2fasta\nGBfile\tnoMito\tunique\n", file=logfile, sep="", append=T)#
#
readin <- grep(pattern, files)#
if (length(readin)==0){#
	folders <- files#
	readin <- c()}else{#
folders <- files[-readin]#
readin <- files[readin]}#
#
no_coi_mito <- NULL#
#
for (i in folders){#
readin <- c(list.files(path=i, pattern=pattern, full.names=T), readin)#
}#
folder_path <- paste(folders, "/", sep="")#
for (k in 1:length(readin)){#
#
# extract fasta file!#
gb <- readLines(readin[k])#
sequence_exp <- NULL#
#
range <- grep("//", gb)#
range <- c(1, range)#
for (i in 1:length(range[-1])){#
temp <- gb[range[i]:range[i+1]]#
#
query <- paste("/(gene|CDS|product)=\"(", paste(marker, sep="", collapse="|") ,")\"", sep="")#
cds_pos <- grep("( gene   | CDS   | rRNA   )", temp)#
COX1 <- cds_pos[grep(query, temp[cds_pos+1], ignore.case=T)[1]]#
COX1 <- temp[COX1]#
if(grepl("join", COX1)){COX1 <- c(NA, NA)} else{#
COX1 <- gsub("[[:alpha:]<> ()]", "", COX1)#
COX1 <- as.numeric(c(gsub("(.*)\\.\\..*$", "\\1", COX1), gsub(".*\\.\\.(.*)$", "\\1", COX1)))}#
#
if (!is.na(COX1[1])&!is.na(COX1[2])){#
sequ <- temp[(grep("ORIGIN      ", temp)+2):length(temp)-1]#
sequ <- paste(gsub("[ 1234567890]", "", sequ), collapse="")#
#
sequ <- substr(sequ, COX1[1]-add, COX1[2]+add)#
sequ_name <- gsub(".* (.*)$", "\\1", temp[grep("ACCESSION ", temp)])#
sequence_exp <- c(sequence_exp, paste(">", sequ_name, "\n", sep=""), paste(sequ, "\n", sep=""))} else { # export mito with no marker#
no_coi_mito <- c(no_coi_mito, gsub(".* (.*)$", "\\1", temp[grep("ACCESSION ", temp)]))#
if (no_marker){dir.create("mito_no_marker", showWarnings=F)#
Fname <- sub(pattern, "\\1", readin[k])#
Fname <- sub(".*/(.*)", "\\1", Fname)#
#torder <- readLines(logfile)[grep("#mito_data: Folder .*", readLines(logfile))][1]#
#torder <- sub("#mito_data: Folder (.*)", "\\1", torder)#
Fname1 <- paste("mito_no_marker/", setwd, if(!is.null(setwd)){"_"}, Fname, ".gb", sep="")#
#
if(temp[1]=="//") ( temp <- temp[-c(1,2)])#
#
cat(temp, file=Fname1, sep="\n", append=T)}#
}#
}#
if (!is.null(sequence_exp)){#
if (rm_dup){#
dup <- !duplicated(sequence_exp[seq(2, length(sequence_exp), 2)])#
sequence_exp <- sequence_exp[rep(dup, each = 2)]}#
#
cat(sequence_exp, file=paste(sub(pattern, "\\1", readin[k]), ".fasta", sep=""), sep="") # overwrite old files#
#
# check number of unique sequences#
uni_mito_coi <- length(unique(sequence_exp[seq(2, length(sequence_exp), 2)])) } else {uni_mito_coi <- 0}#
#print(paste("Converted ", length(range[-1])," mitogenome", if(range[-1]==1){""}else{"s"}," of ", readin[k], " to ", uni_mito_coi, " unique ", marker[1], " sequence", if(uni_mito_coi==1){""}else{"s"},".", sep=""))#
cat(paste(readin[k],"\t", length(range[-1]), "\t", uni_mito_coi, "\n", sep=""), file=logfile, sep="", append=T)#
}#
#
cat("#mito_gb2fasta_end\n\n", file=logfile, sep="", append=T)#
#
if (!is.null(no_coi_mito)){#
cat(paste("Mitogenomes in which no marker sequences were detected:", paste(no_coi_mito, collapse=", "), "\n\n"), file=logfile, sep="", append=T)}#
print(paste("\nMitogenomes in which no marker sequences were detected:", paste(no_coi_mito, collapse=", "), "\n"), file=logfile, sep="", append=T)}#
}
